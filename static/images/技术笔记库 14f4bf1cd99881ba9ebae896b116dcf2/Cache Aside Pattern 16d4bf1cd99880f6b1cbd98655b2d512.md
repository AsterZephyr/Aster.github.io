# Cache Aside Pattern

Created: 2024年12月31日 09:07
Status: 完成

### **Cache Aside Pattern 的潜在问题及解决方案**

### 1. **缓存穿透（Cache Penetration）**

- **问题**：当查询的数据在数据库和缓存中都不存在时，每次请求都会直接访问数据库，导致数据库压力过大。
- **解决方案**：
    - 对不存在的数据也缓存一个空值（如 `null`），并设置较短的过期时间。
    - 使用布隆过滤器（Bloom Filter）提前判断数据是否存在。

### 2. **缓存击穿（Cache Breakdown）**

- **问题**：当某个热点数据过期时，大量请求同时访问数据库，导致数据库压力骤增。
- **解决方案**：
    - 使用互斥锁（Mutex Lock），只允许一个线程去加载数据，其他线程等待。
    - 设置热点数据永不过期，或者通过后台定时任务定期更新缓存。

### 3. **缓存雪崩（Cache Avalanche）**

- **问题**：当大量缓存数据同时过期时，大量请求直接访问数据库，导致数据库崩溃。
- **解决方案**：
    - 设置缓存的过期时间时，增加一个随机值，避免大量缓存同时过期。
    - 使用多级缓存（如本地缓存 + 分布式缓存），减少对数据库的直接访问。

### 4. **数据不一致问题**

- **问题**：在写操作中，如果先删除缓存再更新数据库，可能会导致缓存和数据库的数据不一致。
- **解决方案**：
    - 采用**延迟双删**策略：在更新数据库后，延迟一段时间再次删除缓存。
    - 使用消息队列（如 Kafka、RabbitMQ）异步更新缓存。

---

### **Cache Aside Pattern 的变种**

### 1. **Read Through**

- **特点**：缓存层负责从数据库加载数据，应用程序只与缓存交互。
- **适用场景**：缓存层具有自动加载数据的能力（如某些缓存框架）。

### 2. **Write Through**

- **特点**：写操作同时更新缓存和数据库，由缓存层负责同步。
- **适用场景**：需要保证缓存和数据库的强一致性。

### 3. **Write Behind**

- **特点**：写操作只更新缓存，缓存层异步批量更新数据库。
- **适用场景**：对数据库写性能要求较高的场景。

---

### **总结**

Cache Aside Pattern 是一种简单且高效的缓存管理方案，适用于大多数读多写少的场景。它的核心思想是：

- **读操作**：先读缓存，缓存未命中时读数据库并回填缓存。
- **写操作**：先更新数据库，再删除缓存。